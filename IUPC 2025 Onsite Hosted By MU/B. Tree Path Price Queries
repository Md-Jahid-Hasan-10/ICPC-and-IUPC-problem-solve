//! In The Name Of Allah

#include <bits/stdc++.h>
using namespace std;

#define int long long
#define endl '\n'
#define pb push_back
#define pob pop_back
#define make M
#define F first
#define S second
#define all(s) (s).begin(), (s).end()
#define rall(s) s.rbegin(), s.rend()
#define sz(x) (int)x.size()
#define mem(a, b) memset(a, b, sizeof(a))
#define cnt_bit(x) __builtin_popcountll(x)
#define getbit(n, i) (((n) & (1LL << (i))) != 0)
#define msb(x) 64 - __builtin_clzll(x)
#define setbit(n, i) ((n) |= (1LL << (i)))
#define hoise cout << "Hoise" << endl;
#define tham getchar();
#define TxtIO                         \
    freopen("sample.in", "r", stdin); \
    freopen("sample.out", "w", stdout);
#define Fokinnir_moto_kaj_koris_na \
    ios_base::sync_with_stdio(0);  \
    cin.tie(0);                    \
    cout.tie(0);
#define py cout << "YES" << endl
#define pn cout << "NO" << endl
#define PI acos(-1)
#define sum_of(A) accumulate(all(A), 0ll)
#define max_of(A) *max_element(all(A))
#define min_of(A) *min_element(all(A))

typedef long long ll;
typedef double dl;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int, int> pii;
typedef vector<pii> vii;
typedef array<int,3> tu;

ll gcd(ll a, ll b) { return __gcd(a, b); }
ll lcm(ll a, ll b) { return a * (b / gcd(a, b)); }

/*
auto Goriber_function = [&] (int m) -> int{

};
*/

const ll oo = 1e18;
const ll mod = 1e9 + 7;
const ll N = 2e5 + 123;
const int MAXN = 200005;
const int LOG = 20;

 
vector<int> adj[MAXN];
int k[MAXN], p[MAXN];
int parent[MAXN][LOG], depth[MAXN], sz[MAXN];
int head[MAXN], pos[MAXN], parentHLD[MAXN], heavy[MAXN];
int cur_pos,n;

struct PSTNode {
    ll sum;
    PSTNode *left, *right;
    PSTNode() : sum(0), left(nullptr), right(nullptr) {}
    PSTNode(PSTNode* l, PSTNode* r) : left(l), right(r) {
        sum = (left ? left->sum : 0) + (right ? right->sum : 0);
    }
};
 
PSTNode* versions[MAXN]; 
vii all_prices;
 
PSTNode* build(int l, int r){
    if (l == r) return new PSTNode();
    int mid = (l + r) >> 1;
    return new PSTNode(build(l, mid), build(mid + 1, r));
}
 
PSTNode* update(PSTNode* prev, int l, int r, int pos, ll val){
    if (l == r) {
        PSTNode* new_node = new PSTNode();
        new_node->sum = prev->sum + val;
        return new_node;
    }
    int mid = (l + r) >> 1;
    if(pos <= mid){
        return new PSTNode(update(prev->left, l, mid, pos, val), prev->right);
    } 
    else{
        return new PSTNode(prev->left, update(prev->right, mid + 1, r, pos, val));
    }
}
 
ll query(PSTNode* node, int l, int r, int ql, int qr){
    if(!node || ql > r || qr < l)return 0;
    if(ql <= l && r <= qr)return node->sum;
    int mid = (l + r) >> 1;
    return query(node->left, l, mid, ql, qr) + 
           query(node->right, mid + 1, r, ql, qr);
}
int dfs_hld(int u, int p){
    parent[u][0] = p;
    sz[u] = 1;
    int max_sz = 0;
    heavy[u] = -1;
    for(int v : adj[u]){
        if(v == p)continue;
        depth[v] = depth[u] + 1;
        int child_sz = dfs_hld(v, u);
        sz[u] += child_sz;
        if(child_sz > max_sz){
            max_sz = child_sz;
            heavy[u] = v;
        }
    }
    return sz[u];
}
void decompose(int u, int h, int p){
    head[u] = h;
    pos[u] = cur_pos++;
    parentHLD[u] = p;
    if(heavy[u] != -1){
        decompose(heavy[u], h, u);
    }
    
    for(int v : adj[u]){
        if(v != p && v != heavy[u]){
            decompose(v, v, u);
        }
    }
}
int kth_ancestor(int u, int k){
    for(int i = 0; i < LOG; i++){
        if(k & (1 << i)){
            u = parent[u][i];
        }
    }
    return u;
}
void Goriber_solve()
{
    cin >> n;
    for(int i = 1; i < n; i++){
        int a,b;
        cin >> a >> b;
        adj[a].pb(b);
        adj[b].pb(a);
    }
    for(int i = 1; i <= n; i++){
        cin >> k[i] >> p[i];
        all_prices.pb({p[i],i});
    }
    for(int i = 0; i < LOG; i++){
        for(int j = 1; j <= n; j++){
            parent[j][i] = 0;
        }
    }
    depth[1] = 0;
    dfs_hld(1, 0);
    cur_pos = 0;
    decompose(1, 1, 0);
    for(int i = 1; i < LOG; i++){
        for(int u = 1; u <= n; u++){
            if(parent[u][i-1] != 0){
                parent[u][i] = parent[parent[u][i-1]][i-1];
            }
        }
    }
    sort(all(all_prices));
    vector<int> comp_idx(n + 1);
    vector<int> sorted_prices;
    for(int i = 0; i < n; i++){
        comp_idx[all_prices[i].second] = i;
        sorted_prices.push_back(all_prices[i].first);
    }
    vii hld_order(n);
    for(int i = 1; i <= n; i++){
        hld_order[pos[i]] = {comp_idx[i], i};
    }
    int m = all_prices.size();
    versions[0] = build(0, m - 1);
    for(int i = 0; i < n; i++){
        int idx = hld_order[i].first;
        int node = hld_order[i].second;
        versions[i + 1] = update(versions[i], 0, m - 1, idx, k[node]);
    }
    auto get_price_range = [&](int pl, int pr) -> pair<int, int> {
        int l = lower_bound(sorted_prices.begin(), sorted_prices.end(), pl) - sorted_prices.begin();
        int r = upper_bound(sorted_prices.begin(), sorted_prices.end(), pr) - sorted_prices.begin() - 1;
        return {l, r};
    };
    int q;
    cin >> q;
    ll last_ans = 0;
    for(int i = 0; i < q; i++){
        int Ui, Di, PLi, PUi;
        cin >> Ui >> Di >> PLi >> PUi;
        int u = ((Ui + last_ans) % n) + 1;
        int d = (Di + last_ans) % n;
        int plower = ((PLi + last_ans) % 1000000000) + 1;
        int pupper = ((PUi + last_ans) % 1000000000) + 1;
        
        if(plower > pupper) swap(plower, pupper);
        int target = u;
        if(depth[u] > d){
            target = kth_ancestor(u, d);
        } 
        else{
            target = 1;
        }
        auto pp = get_price_range(plower, pupper);
        int price_l = pp.first, price_r = pp.second;
        if (price_l > price_r) {
            cout << "0\n";
            last_ans = 0;
            continue;
        }
        ll ans = 0;
        while(head[u] != head[target]){
            int l = pos[head[u]];
            int r = pos[u];
            ans += query(versions[r + 1], 0, m - 1, price_l, price_r) -
                   query(versions[l], 0, m - 1, price_l, price_r);
            u = parentHLD[head[u]];
        }
        int l = pos[target];
        int r = pos[u];
        ans += query(versions[r + 1], 0, m - 1, price_l, price_r) -
               query(versions[l], 0, m - 1, price_l, price_r);
        
        cout << ans << "\n";
        last_ans = ans;
    }
}

signed main()
{
    Fokinnir_moto_kaj_koris_na
    int _ = 1,tc = 0;
    //cin >> _;
    while (_--)
    {
        //cout<<"Case "<<++tc<<": ";
        Goriber_solve();
    }
    return 0;
}

    
